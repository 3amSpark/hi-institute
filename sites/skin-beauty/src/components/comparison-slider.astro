---
type Props = {
  beforeImage: string;
  afterImage: string;
  beforeAlt?: string;
  afterAlt?: string;
  beforeLabel?: string;
  afterLabel?: string;
  containerClass?: string;
  initialPosition?: number;
  sliderId?: string;
};

const props = Astro.props as Props;

const {
  beforeImage,
  afterImage,
  beforeAlt = "Before image",
  afterAlt = "After image",
  beforeLabel = "Antes",
  afterLabel = "Despu√©s",
  containerClass = "",
  initialPosition = 50,
  sliderId = `comparison-${Math.random().toString(36).slice(2, 8)}`,
} = Astro.props;

const startPosition = Math.min(100, Math.max(0, initialPosition));
---

<div
  id={sliderId}
  data-comparison-slider
  class={`comparison-root relative aspect-video overflow-hidden select-none ${containerClass}`}
  style={`--pos: ${startPosition}%`}
>
  <div class="comparison-handle" style="left: var(--pos)">
    <div class="comparison-handle__knob">
      <div class="comparison-handle__bar"></div>
      <div class="comparison-handle__bar"></div>
      <div class="comparison-handle__bar"></div>
    </div>
  </div>

  <div class="absolute inset-0">
    <img
      src={afterImage}
      alt={afterAlt}
      class="h-full w-full object-cover"
      loading="lazy"
    />
    {
      afterLabel && (
        <div class="font-heading absolute right-4 bottom-4 z-10 rounded-full bg-black/40 px-3 py-1 text-[10px] font-bold tracking-widest whitespace-nowrap text-white uppercase backdrop-blur-sm">
          {afterLabel}
        </div>
      )
    }
  </div>

  <div class="comparison-mask absolute inset-0">
    <img
      src={beforeImage}
      alt={beforeAlt}
      class="h-full w-full object-cover"
      loading="lazy"
    />
    {
      beforeLabel && (
        <div class="font-heading absolute bottom-4 left-4 z-10 rounded-full bg-white/40 px-3 py-1 text-[10px] font-bold tracking-widest whitespace-nowrap text-black uppercase backdrop-blur-sm">
          {beforeLabel}
        </div>
      )
    }
  </div>
</div>

<style>
  .comparison-handle {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 2px;
    transform: translateX(-50%);
    background: white;
    z-index: 20;
    cursor: col-resize;
    transition: opacity 0.3s ease;
  }

  .comparison-root[data-dragging] .comparison-handle {
    opacity: 0;
  }

  .comparison-handle__knob {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 2.5rem;
    height: 2.5rem;
    transform: translate(-50%, -50%);
    border-radius: 9999px;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2px;
    box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.2);
  }

  .comparison-handle__bar {
    width: 2px;
    height: 12px;
    background: #d1d5db;
    border-radius: 1px;
  }

  .comparison-handle__bar:nth-child(2) {
    height: 16px;
    background: var(--color-brand, #000);
  }

  .comparison-mask {
    mask-image: linear-gradient(
      to right,
      black 0%,
      black var(--pos),
      transparent var(--pos),
      transparent 100%
    );
    -webkit-mask-image: linear-gradient(
      to right,
      black 0%,
      black var(--pos),
      transparent var(--pos),
      transparent 100%
    );
  }

  .comparison-root {
    touch-action: none;
  }
</style>

<script define:vars={{ sliderId }}>
  (() => {
    const container = document.getElementById(sliderId);
    if (!container) return;

    let isDragging = false;

    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

    const updatePosition = (clientX) => {
      const rect = container.getBoundingClientRect();
      const x = clamp(clientX - rect.left, 0, rect.width);
      const percent = (x / rect.width) * 100;
      container.style.setProperty("--pos", `${percent}%`);
    };

    const onPointerDown = (event) => {
      isDragging = true;
      container.setAttribute("data-dragging", "");
      container.setPointerCapture(event.pointerId);
      updatePosition(event.clientX);
    };

    const onPointerMove = (event) => {
      if (!isDragging) return;
      event.preventDefault();
      updatePosition(event.clientX);
    };

    const stopDragging = (event) => {
      if (!isDragging) return;
      isDragging = false;
      container.removeAttribute("data-dragging");
      container.releasePointerCapture(event.pointerId);
    };

    container.addEventListener("pointerdown", onPointerDown);
    container.addEventListener("pointermove", onPointerMove);
    container.addEventListener("pointerup", stopDragging);
    container.addEventListener("pointercancel", stopDragging);
  })();
</script>
