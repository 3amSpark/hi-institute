---
import FadeIn from "./fade-in.astro";
import Heading from "./heading.astro";
import ArrowRight from "../icons/arrow-right.astro";

interface Props {
  title?: string;
  items: {
    title: string;
    description: string;
    image: string;
  }[];
  overlayOpacity?: number;
}

const { title, items, overlayOpacity = 1 } = Astro.props;
---

<reveal-carousel
  class="block bg-brand-gray/5 px-4 py-20"
  style={`--overlay-opacity: ${overlayOpacity}`}
>
  <div class="mx-auto max-w-6xl">
    {
      title && (
        <FadeIn duration={1} delay={0}>
          <Heading
            level={3}
            className="text-brand-gray mb-16 text-center font-medium"
            text={title}
          />
        </FadeIn>
      )
    }

    <div class="relative">
      <!-- Navigation Arrows -->
      <button
        data-carousel-prev
        class="text-brand-gray/40 bg-white rounded-full p-2 hover:text-brand-gray absolute top-1/2 -left-4 z-10 hidden -translate-y-1/2 cursor-pointer text-4xl transition-opacity duration-300 md:block border border-brand-gray/20 opacity-0 pointer-events-none"
        aria-label="Anterior"
      >
        <ArrowRight class="text-brand-gray size-6 -scale-x-100" />
      </button>
      <button
        data-carousel-next
        class="text-brand-gray/40 bg-white rounded-full p-2 hover:text-brand-gray absolute top-1/2 -right-4 z-10 hidden -translate-y-1/2 cursor-pointer text-4xl transition-opacity duration-300 md:block border border-brand-gray/20 opacity-0 pointer-events-none"
        aria-label="Siguiente"
      >
        <ArrowRight class="text-brand-gray size-6" />
      </button>

      <!-- Carousel Container -->
      <div
        data-carousel-container
        class="scrollbar-hide flex gap-4 overflow-x-auto pb-4"
      >
        {
          items.map((item, i) => (
            <FadeIn
              duration={1}
              delay={i * 0.1}
              class="w-[calc(100%-32px)] shrink-0 sm:w-[calc(50%-8px)] md:w-[calc(33.333%-10.667px)] lg:w-[calc(25%-12px)]"
            >
              <div class="condition-card group relative aspect-square md:aspect-auto md:h-96 cursor-pointer overflow-hidden rounded-2xl transition-all duration-500 ease-out hover:rounded-3xl">
                <img
                  src={item.image}
                  alt={item.title}
                  class="h-full w-full object-cover transition-transform duration-500 group-hover:scale-105"
                />

                <!-- Content container -->
                <div class="absolute inset-x-0 bottom-0 z-10 overflow-hidden p-6">
                  <h4 class="font-heading text-xl font-medium text-white text-shadow-sm">
                    {item.title}
                  </h4>
                  <div class="grid grid-rows-[1fr] transition-all duration-500 ease-out md:grid-rows-[0fr] md:group-hover:grid-rows-[1fr]">
                    <p class="font-heading overflow-hidden pt-2 text-sm leading-relaxed text-white/90 opacity-100 transition-all duration-500 ease-out md:pt-0 md:opacity-0 md:group-hover:pt-2 md:group-hover:opacity-100">
                      {item.description}
                    </p>
                  </div>
                </div>
              </div>
            </FadeIn>
          ) )
        }
      </div>
    </div>
  </div>
</reveal-carousel>

<script>
  import { gsap } from "gsap";
  import { ScrollToPlugin } from "gsap/ScrollToPlugin";

  gsap.registerPlugin(ScrollToPlugin);

  class RevealCarousel extends HTMLElement {
    connectedCallback() {
      const container = this.querySelector('[data-carousel-container]') as HTMLElement;
      const prevBtn = this.querySelector('[data-carousel-prev]') as HTMLElement;
      const nextBtn = this.querySelector('[data-carousel-next]') as HTMLElement;

      if (!container) return;

      const getScrollAmount = () => {
        const card = container.querySelector("fade-in") as HTMLElement;
        return card ? card.offsetWidth + 16 : 300; // card width + gap
      };

      const getMaxScroll = () => {
        return container.scrollWidth - container.clientWidth;
      };

      const updateArrowVisibility = () => {
        const maxScroll = getMaxScroll();
        const canScroll = maxScroll > 1; // Use 1px threshold to account for rounding

        if (!canScroll) {
          // Hide both arrows if content fits
          prevBtn?.classList.add("opacity-0", "pointer-events-none");
          nextBtn?.classList.add("opacity-0", "pointer-events-none");
          return;
        }

        // Show arrows if content overflows
        prevBtn?.classList.remove("opacity-0", "pointer-events-none");
        nextBtn?.classList.remove("opacity-0", "pointer-events-none");

        // Update individual arrow visibility based on scroll position
        if (container.scrollLeft <= 1) {
          prevBtn?.classList.add("opacity-0", "pointer-events-none");
        } else {
          prevBtn?.classList.remove("opacity-0", "pointer-events-none");
        }

        if (container.scrollLeft >= maxScroll - 1) {
          nextBtn?.classList.add("opacity-0", "pointer-events-none");
        } else {
          nextBtn?.classList.remove("opacity-0", "pointer-events-none");
        }
      };

      // Initial check
      // Use setTimeout to ensure layout is complete
      setTimeout(() => {
        updateArrowVisibility();
      }, 100);

      // Update on scroll
      container.addEventListener("scroll", updateArrowVisibility);

      // Update on resize
      const resizeObserver = new ResizeObserver(() => {
        updateArrowVisibility();
      });
      resizeObserver.observe(container);

      prevBtn?.addEventListener("click", () => {
        const scrollAmount = getScrollAmount();
        const targetScroll = Math.max(0, container.scrollLeft - scrollAmount);
        gsap.to(container, {
          scrollTo: { x: targetScroll },
          duration: 1.2,
          ease: "power3.out",
          onComplete: updateArrowVisibility,
        });
      });

      nextBtn?.addEventListener("click", () => {
        const scrollAmount = getScrollAmount();
        const maxScroll = getMaxScroll();
        const targetScroll = Math.min(
          maxScroll,
          container.scrollLeft + scrollAmount
        );
        gsap.to(container, {
          scrollTo: { x: targetScroll },
          duration: 0.8,
          ease: "power3.out",
          onComplete: updateArrowVisibility,
        });
      });
    }
  }

  customElements.define("reveal-carousel", RevealCarousel);
</script>

<style>
  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }

  .condition-card {
    &::before,
    &::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* Gradient Wipe - always visible with mask on mobile */
    &::before {
      background: var(--brand-gradient);
      mask: linear-gradient(to bottom, transparent 0%, black 100%);
      transform: scaleY(1);
      transform-origin: bottom;
      transition: transform var(--spring-duration) var(--spring-easing);
      z-index: 2;
    }

    /* Blend Mode Overlay (always visible) */
    &::after {
      background: var(--brand-gradient);
      mix-blend-mode: multiply;
      opacity: var(--overlay-opacity);
      z-index: 1;
    }

    /* Desktop: no mask, wipe on hover */
    @media (min-width: 768px) {
      &::before {
        mask: none;
        transform: scaleY(0);
        transform-origin: top;
      }

      &:hover::before {
        transform: scaleY(1);
        transform-origin: bottom;
      }
    }
  }
</style>

